{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home The Coastal Ecosystem Enhancement Decision Support (CEEDS) tool is a critical component of the Sustainable Management of Marine Resources (SMMR) funded Restoration of Seagrass for Ocean Wealth (ReSOW) UK project. The CEEDS Tool brings together all data and reports from the project in a manner that is accessible and can be explored spatially, aligning with the needs and priorities of our community. General Project Infrastructure This project is based on a web-client that accesses data from different locations and uses various microservices related to APIs and tile servers. Below, we will describe the project's infrastructure in more detail. As shown in the figure above, both the frontend and all microservices are running in Docker containers. These Docker containers are stored in a container registry. Currently, we are using gitlab container registry. The containers are updated each time a push is made to the master repository of the container. Repositories These are the project repositories: Frontend : A frontend application created in React, with the ability to interact with different data formats on both the backend and frontend. This project depends on certain backend services to perform tile server activities, as well as authentication and data calculations. Tileserver : Repository for configuring and creating tile servers. Geoserver : Repository for configuring and creating geoserver. Data Pipelines : This repository contains all the code for data format conversion, data uploading to the Object Store, and STAC Catalog creation. SALT Stack : Repository contaning the Salt configuration for the VM. Server Instance Organization The organization of server instances is carried out through the SALT Stack repository. This repository is based on the configuration of server stacks in the Salt project . More information about the use and configuration of Salt can be found in the Salt repository in this project . Deploying the Project To deploy the project, follow the procedures described here . CI/CD Pipeline This repository includes an automatic GitLab CI/CD pipeline for continuous integration and continuous deployment. More information about this pipeline can be found in the CI/CD Pipeline documentation . Data Organization: Object Store and STAC Catalog All project data files are stored in an object store. In this case, the files are accessed via HTTP requests, without the need for an intermediate database or an API. As the object store appears as a group of files, it is necessary to create a catalog of these files, called an STAC Catalog . The STAC catalog for this project can be accessed here . For more information on how to generate the STAC Catalog, refer to the Data Pipelines repository . This project suggests an organization of files in the Object Store, as described here . If you want to understand a little bit more about how we deal with STAC Catalogs, please click here . Data Format Conversion In this project, data from different formats is converted into formats optimized for the cloud. Data conversion is performed through a series of Python codes that convert data from the following formats: GeoTIFF, GeoJSON, Shapefile, FlatGeoBuf, COG, Zarr, NetCDF, among others. The codes for converting data are described in the Data Pipelines repository . More information about all the data types that we have been working with are described below: GeoTIFF and Cloud Optimized GeoTIFF (COG) FlatGeoBuf Geoserver WMS Layers Cesium Ion Frontend Application The frontend application was developed in React and is converted into a Docker container. This app is currently running on Jasmin and Oracle Cloud and can be accessed via the link https://ceeds.resow.uk . You can find a detailed explanation about all the frontend features here . More information about the frontend application can be found in the repository: https://gitlab.com/nocacuk/ocean-informatics/ReSOW/frontend Tile Servers Some data formats require the use of tile servers to optimize data rendering on the frontend. For this project, the following servers are used: 1) Titiler: FastAPI application for dynamic tiling. It is used for COG files. You can see more information here . 2) Geoserver: An open source server for sharing geospatial data. You can see more information here . The tile servers are converted into Docker containers. More information about the servers can be found in the repositories: - Tileserver . - Geoserver .","title":"Home"},{"location":"#home","text":"The Coastal Ecosystem Enhancement Decision Support (CEEDS) tool is a critical component of the Sustainable Management of Marine Resources (SMMR) funded Restoration of Seagrass for Ocean Wealth (ReSOW) UK project. The CEEDS Tool brings together all data and reports from the project in a manner that is accessible and can be explored spatially, aligning with the needs and priorities of our community.","title":"Home"},{"location":"#general-project-infrastructure","text":"This project is based on a web-client that accesses data from different locations and uses various microservices related to APIs and tile servers. Below, we will describe the project's infrastructure in more detail. As shown in the figure above, both the frontend and all microservices are running in Docker containers. These Docker containers are stored in a container registry. Currently, we are using gitlab container registry. The containers are updated each time a push is made to the master repository of the container.","title":"General Project Infrastructure"},{"location":"#repositories","text":"These are the project repositories: Frontend : A frontend application created in React, with the ability to interact with different data formats on both the backend and frontend. This project depends on certain backend services to perform tile server activities, as well as authentication and data calculations. Tileserver : Repository for configuring and creating tile servers. Geoserver : Repository for configuring and creating geoserver. Data Pipelines : This repository contains all the code for data format conversion, data uploading to the Object Store, and STAC Catalog creation. SALT Stack : Repository contaning the Salt configuration for the VM.","title":"Repositories"},{"location":"#server-instance-organization","text":"The organization of server instances is carried out through the SALT Stack repository. This repository is based on the configuration of server stacks in the Salt project . More information about the use and configuration of Salt can be found in the Salt repository in this project .","title":"Server Instance Organization"},{"location":"#deploying-the-project","text":"To deploy the project, follow the procedures described here .","title":"Deploying the Project"},{"location":"#cicd-pipeline","text":"This repository includes an automatic GitLab CI/CD pipeline for continuous integration and continuous deployment. More information about this pipeline can be found in the CI/CD Pipeline documentation .","title":"CI/CD Pipeline"},{"location":"#data-organization-object-store-and-stac-catalog","text":"All project data files are stored in an object store. In this case, the files are accessed via HTTP requests, without the need for an intermediate database or an API. As the object store appears as a group of files, it is necessary to create a catalog of these files, called an STAC Catalog . The STAC catalog for this project can be accessed here . For more information on how to generate the STAC Catalog, refer to the Data Pipelines repository . This project suggests an organization of files in the Object Store, as described here . If you want to understand a little bit more about how we deal with STAC Catalogs, please click here .","title":"Data Organization: Object Store and STAC Catalog"},{"location":"#data-format-conversion","text":"In this project, data from different formats is converted into formats optimized for the cloud. Data conversion is performed through a series of Python codes that convert data from the following formats: GeoTIFF, GeoJSON, Shapefile, FlatGeoBuf, COG, Zarr, NetCDF, among others. The codes for converting data are described in the Data Pipelines repository . More information about all the data types that we have been working with are described below: GeoTIFF and Cloud Optimized GeoTIFF (COG) FlatGeoBuf Geoserver WMS Layers Cesium Ion","title":"Data Format Conversion"},{"location":"#frontend-application","text":"The frontend application was developed in React and is converted into a Docker container. This app is currently running on Jasmin and Oracle Cloud and can be accessed via the link https://ceeds.resow.uk . You can find a detailed explanation about all the frontend features here . More information about the frontend application can be found in the repository: https://gitlab.com/nocacuk/ocean-informatics/ReSOW/frontend","title":"Frontend Application"},{"location":"#tile-servers","text":"Some data formats require the use of tile servers to optimize data rendering on the frontend. For this project, the following servers are used: 1) Titiler: FastAPI application for dynamic tiling. It is used for COG files. You can see more information here . 2) Geoserver: An open source server for sharing geospatial data. You can see more information here . The tile servers are converted into Docker containers. More information about the servers can be found in the repositories: - Tileserver . - Geoserver .","title":"Tile Servers"},{"location":"2dmap/","text":"2D Map Introduction Our 2D map version is built upon the React Leaflet library, offering a feature-rich platform for visualizing geospatial data. In this documentation, we'll delve into the details of our 2D map implementation, the base map layers used, and how interaction with the map is facilitated. The Foundation: React Leaflet To create our 2D map, we've harnessed the power of the React Leaflet library. React Leaflet provides a robust framework for building interactive and visually engaging maps within a React application. To enhance our map's capabilities and interactivity, we've developed additional packages, which will be detailed in the following sections. Base Map Layers Work in progress A map's foundation lies in its base layers, and for our 2D map, we have incorporated the following base layers: OpenStreetMap : This layer is sourced from OpenStreetMap and is accessible via the following URL: OpenStreetMap Layer . NASA Blue Marble : This layer is derived from NASA's Blue Marble imagery and can be accessed through the URL: NASA Blue Marble Layer . These base layers provide essential geographical context for our 2D map, serving as a canvas on which various geospatial data can be visualized. WORK IN PROGRESS Map Interaction Interacting with the map is a fundamental aspect of geospatial applications. In our implementation, interaction with the map is facilitated through the definition of a 'ref' prop within the MapContainer component from React Leaflet. This 'ref' prop is passed a setState function called setMap, created within the Map component. When a layer is added to the map, it is assigned a unique 'attribution' value. This attribution value is crucial for identifying and interacting with specific layers on the map. We utilize this value to perform the necessary operations when interacting with the layer. It's worth mentioning that due to certain restrictions in Webpack for use with React Vite, we faced limitations in adding multiple Leaflet auxiliary libraries to the project. To overcome this challenge, these libraries were manually included in the project by copying the associated .js files to the repository. The following libraries have been integrated: leaflet-ruler.js : This library allows users to measure distances on the map. vectorgrid : Enables the addition of MBTiles files to the map. CanvasLayers : Provides support for adding .asc files to the map. This combination of React Leaflet, base map layers, and supplementary libraries ensures a feature-rich and interactive 2D map for our geospatial applications. WORK IN PROGRESS","title":"2D Map"},{"location":"2dmap/#2d-map","text":"","title":"2D Map"},{"location":"2dmap/#introduction","text":"Our 2D map version is built upon the React Leaflet library, offering a feature-rich platform for visualizing geospatial data. In this documentation, we'll delve into the details of our 2D map implementation, the base map layers used, and how interaction with the map is facilitated.","title":"Introduction"},{"location":"2dmap/#the-foundation-react-leaflet","text":"To create our 2D map, we've harnessed the power of the React Leaflet library. React Leaflet provides a robust framework for building interactive and visually engaging maps within a React application. To enhance our map's capabilities and interactivity, we've developed additional packages, which will be detailed in the following sections.","title":"The Foundation: React Leaflet"},{"location":"2dmap/#base-map-layers","text":"Work in progress A map's foundation lies in its base layers, and for our 2D map, we have incorporated the following base layers: OpenStreetMap : This layer is sourced from OpenStreetMap and is accessible via the following URL: OpenStreetMap Layer . NASA Blue Marble : This layer is derived from NASA's Blue Marble imagery and can be accessed through the URL: NASA Blue Marble Layer . These base layers provide essential geographical context for our 2D map, serving as a canvas on which various geospatial data can be visualized. WORK IN PROGRESS","title":"Base Map Layers"},{"location":"2dmap/#map-interaction","text":"Interacting with the map is a fundamental aspect of geospatial applications. In our implementation, interaction with the map is facilitated through the definition of a 'ref' prop within the MapContainer component from React Leaflet. This 'ref' prop is passed a setState function called setMap, created within the Map component. When a layer is added to the map, it is assigned a unique 'attribution' value. This attribution value is crucial for identifying and interacting with specific layers on the map. We utilize this value to perform the necessary operations when interacting with the layer. It's worth mentioning that due to certain restrictions in Webpack for use with React Vite, we faced limitations in adding multiple Leaflet auxiliary libraries to the project. To overcome this challenge, these libraries were manually included in the project by copying the associated .js files to the repository. The following libraries have been integrated: leaflet-ruler.js : This library allows users to measure distances on the map. vectorgrid : Enables the addition of MBTiles files to the map. CanvasLayers : Provides support for adding .asc files to the map. This combination of React Leaflet, base map layers, and supplementary libraries ensures a feature-rich and interactive 2D map for our geospatial applications. WORK IN PROGRESS","title":"Map Interaction"},{"location":"3dmap/","text":"3D Map Introduction Our 3D map version is built upon the Resium library, which is essentially Cesium for React. This powerful library serves as the foundation for creating interactive and immersive 3D geospatial experiences within our application. In this documentation, we'll explore the details of our 3D map implementation, interactions with the map, and essential observations for development and production use. The image above provides an overview of our 3D map utilizing Resium. Map Interaction Interacting with the 3D map is a critical aspect of our geospatial application. To enable map interaction, we define a 'ref' prop within the Resium Viewer component. This 'ref' prop is passed a useRef created within the 3D Map component. This approach provides a means for managing and interacting with the 3D map. Similar to the 2D map, layers added to the 3D map are assigned a unique 'attribution' value. This value is vital for identifying and interacting with specific layers on the map. When an operation or interaction with a layer is required, the map seeks the layer with the corresponding attribution value, allowing for seamless interaction. It's essential to note that the Cesium library handles layers differently from Leaflet. In Cesium, each type of layer is treated as a separate component. Furthermore, some layers in Cesium are not easily modifiable. This has led to the decision to remove and re-add layers in many cases to ensure they function as intended. Important Observations While developing with React, it's important to be aware of a characteristic where React renders all components on the page twice. This behavior is a valuable feature for development testing but can present challenges when working with Resium. In practice, React renders two 3D maps, with only the second map being interactive. To address this and ensure that you can effectively test and use the map during development, follow these steps: Remove the 'full' prop from the Viewer component. Add the following information to the 'styles.ts' file of the 3D map component: export const ResiumContainer = styled.div` /* div:first-child { div:first-child { height: 500px; } } */ ` These adjustments should be removed when deploying the application for production use. Additional Note It's worth mentioning that we have also implemented an example map using MapBox3D. However, it is not currently in production and serves as a separate experimental component. Our 3D map implementation opens up new possibilities for immersive geospatial experiences, and we are committed to continually enhancing its functionality. If you have any questions or need further information regarding our 3D map implementation, please consult the project repository or reach out to our support team for assistance.","title":"3D Map"},{"location":"3dmap/#3d-map","text":"","title":"3D Map"},{"location":"3dmap/#introduction","text":"Our 3D map version is built upon the Resium library, which is essentially Cesium for React. This powerful library serves as the foundation for creating interactive and immersive 3D geospatial experiences within our application. In this documentation, we'll explore the details of our 3D map implementation, interactions with the map, and essential observations for development and production use. The image above provides an overview of our 3D map utilizing Resium.","title":"Introduction"},{"location":"3dmap/#map-interaction","text":"Interacting with the 3D map is a critical aspect of our geospatial application. To enable map interaction, we define a 'ref' prop within the Resium Viewer component. This 'ref' prop is passed a useRef created within the 3D Map component. This approach provides a means for managing and interacting with the 3D map. Similar to the 2D map, layers added to the 3D map are assigned a unique 'attribution' value. This value is vital for identifying and interacting with specific layers on the map. When an operation or interaction with a layer is required, the map seeks the layer with the corresponding attribution value, allowing for seamless interaction. It's essential to note that the Cesium library handles layers differently from Leaflet. In Cesium, each type of layer is treated as a separate component. Furthermore, some layers in Cesium are not easily modifiable. This has led to the decision to remove and re-add layers in many cases to ensure they function as intended.","title":"Map Interaction"},{"location":"3dmap/#important-observations","text":"While developing with React, it's important to be aware of a characteristic where React renders all components on the page twice. This behavior is a valuable feature for development testing but can present challenges when working with Resium. In practice, React renders two 3D maps, with only the second map being interactive. To address this and ensure that you can effectively test and use the map during development, follow these steps: Remove the 'full' prop from the Viewer component. Add the following information to the 'styles.ts' file of the 3D map component: export const ResiumContainer = styled.div` /* div:first-child { div:first-child { height: 500px; } } */ ` These adjustments should be removed when deploying the application for production use.","title":"Important Observations"},{"location":"3dmap/#additional-note","text":"It's worth mentioning that we have also implemented an example map using MapBox3D. However, it is not currently in production and serves as a separate experimental component. Our 3D map implementation opens up new possibilities for immersive geospatial experiences, and we are committed to continually enhancing its functionality. If you have any questions or need further information regarding our 3D map implementation, please consult the project repository or reach out to our support team for assistance.","title":"Additional Note"},{"location":"cesium_ion/","text":"Cesium Ion 3D Layers This guide will take you through the process of opening Cesium Ion 3D layers in a React TypeScript (TSX) application using Resium. Cesium Ion is a cloud-based platform for creating, hosting, and streaming 3D geospatial content, while Resium is a library for integrating Cesium 3D globes with React. Configuring Cesium Ion Sign Up for Cesium Ion Before you can use Cesium Ion, you need to create an account on Cesium Ion . Once you have an account, you can obtain your access token. Set Your Access Token Add your Access Token value to the .env file: VITE_CESIUM_TOKEN= In the tsx file, set your Cesium Ion access token by including the following code in your application's entry point (e.g., index.tsx ): import { Ion } from 'cesium' Ion.defaultAccessToken = process.env.VITE_CESIUM_TOKEN Opening a Cesium Ion 3D Layer Import Required Modules Import the necessary modules: import React from 'react'; import { Viewer } from 'resium'; Define the Cesium Ion Layer Define the Cesium Ion layer within your component: const assetId = 'ASSET ID FROM THE CESIUM ION ACCOUNT' const terrainUrl = await Cesium.CesiumTerrainProvider.fromIonAssetId( assetId, ) ref.current.cesiumElement.terrainProvider = terrainUrl Please note that you will need to replace 'ASSET ID FROM THE CESIUM ION ACCOUNT' with the actual asset ID you want to use from your Cesium Ion account.","title":"Cesium Ion 3D Layers"},{"location":"cesium_ion/#cesium-ion-3d-layers","text":"This guide will take you through the process of opening Cesium Ion 3D layers in a React TypeScript (TSX) application using Resium. Cesium Ion is a cloud-based platform for creating, hosting, and streaming 3D geospatial content, while Resium is a library for integrating Cesium 3D globes with React.","title":"Cesium Ion 3D Layers"},{"location":"cesium_ion/#configuring-cesium-ion","text":"Sign Up for Cesium Ion Before you can use Cesium Ion, you need to create an account on Cesium Ion . Once you have an account, you can obtain your access token. Set Your Access Token Add your Access Token value to the .env file: VITE_CESIUM_TOKEN= In the tsx file, set your Cesium Ion access token by including the following code in your application's entry point (e.g., index.tsx ): import { Ion } from 'cesium' Ion.defaultAccessToken = process.env.VITE_CESIUM_TOKEN","title":"Configuring Cesium Ion"},{"location":"cesium_ion/#opening-a-cesium-ion-3d-layer","text":"Import Required Modules Import the necessary modules: import React from 'react'; import { Viewer } from 'resium'; Define the Cesium Ion Layer Define the Cesium Ion layer within your component: const assetId = 'ASSET ID FROM THE CESIUM ION ACCOUNT' const terrainUrl = await Cesium.CesiumTerrainProvider.fromIonAssetId( assetId, ) ref.current.cesiumElement.terrainProvider = terrainUrl Please note that you will need to replace 'ASSET ID FROM THE CESIUM ION ACCOUNT' with the actual asset ID you want to use from your Cesium Ion account.","title":"Opening a Cesium Ion 3D Layer"},{"location":"cicd/","text":"CI/CD Pipeline Documentation There is an automatic gitlab CI/CD pipeline in this project. It is split into this jobs: Build The Build job is in charge of building the Docker container. The container is tagged based on the container registry name used in the project. Deploy The Deploy job handles the deployment process. It pushes the built container to the Gitlab container registry. Subsequently, it SSHs into the host named \"web\" or \"tiling\", retrieves the container, and restarts it. This process requires the presence of a GitLab Runner user on both the build and web or tiling virtual machines. An SSH key must also be configured to allow the build to SSH into the web. Please note that while the salt rules repository can create the user and allow manual key generation for login, it does not generate that key. In the event of VM reinstallation, new SSH keys must be created, and the salt rules (salt/user/gitlab-runner.sls) must be updated with the new keys. Firewall Complications Please be aware of potential complications with the NOC firewall, which only allows requests from the fixed IP of the gateway VM. To overcome this restriction, the deploy script sets up an SSH SOCKS proxy on port 3128 via the gateway for pushing and pulling containers. The Docker configuration is adjusted to use localhost:3128 as a proxy, which requires the SSH tunnel to be running. You can initiate the SSH tunnel with the command ssh -D 3128 -f -N gateway before executing any docker login, push, or pull commands. To stop the SSH tunnel, use pkill -f \"ssh -D 3128 -f -N gateway\" .","title":"CI/CD Pipeline Documentation"},{"location":"cicd/#cicd-pipeline-documentation","text":"There is an automatic gitlab CI/CD pipeline in this project. It is split into this jobs:","title":"CI/CD Pipeline Documentation"},{"location":"cicd/#build","text":"The Build job is in charge of building the Docker container. The container is tagged based on the container registry name used in the project.","title":"Build"},{"location":"cicd/#deploy","text":"The Deploy job handles the deployment process. It pushes the built container to the Gitlab container registry. Subsequently, it SSHs into the host named \"web\" or \"tiling\", retrieves the container, and restarts it. This process requires the presence of a GitLab Runner user on both the build and web or tiling virtual machines. An SSH key must also be configured to allow the build to SSH into the web. Please note that while the salt rules repository can create the user and allow manual key generation for login, it does not generate that key. In the event of VM reinstallation, new SSH keys must be created, and the salt rules (salt/user/gitlab-runner.sls) must be updated with the new keys.","title":"Deploy"},{"location":"cicd/#firewall-complications","text":"Please be aware of potential complications with the NOC firewall, which only allows requests from the fixed IP of the gateway VM. To overcome this restriction, the deploy script sets up an SSH SOCKS proxy on port 3128 via the gateway for pushing and pulling containers. The Docker configuration is adjusted to use localhost:3128 as a proxy, which requires the SSH tunnel to be running. You can initiate the SSH tunnel with the command ssh -D 3128 -f -N gateway before executing any docker login, push, or pull commands. To stop the SSH tunnel, use pkill -f \"ssh -D 3128 -f -N gateway\" .","title":"Firewall Complications"},{"location":"deploy/","text":"How to Deploy the Digital Twin to a New Server Prerequisites You will need four virtual machines running Ubuntu 22.04, each with 4-8GB of RAM and 10GB of disk space for the OS. Additionally, two of these machines should have an extra 50GB of disk space (can be on an additional disk/volume). The four virtual machines are as follows: - gateway : Runs an Apache transparent proxy server for all services, sets up Let's Encrypt certificates, and provides SSL connections to web apps. - web : Runs the web apps as Docker containers. - tiling : Runs the tile servers as Docker containers. - build : Functions as a GitLab runner for building and deploying. Only the gateway VM needs an internet-routable IP address. Ensure that you have set the IP address of each system in the Salt pillar hosts file (pillar/hosts.sls) or made sure that the names gateway , web , and build are resolvable via DNS. These virtual machines can be created using the Salt configuration for this project: Salt Configuration Repository . Environment Configuration You need to set a list of secrets on the CI/CD configuration on GitLab, as described below: VITE_CESIUM_TOKEN: the token for the Cesium ION Api. It is necessary in order to access the 3d visualisation VITE_MAPBOX_API_KEY: the api key for the mapbox satellite layers VITE_ESRI: [OPTIONAL] the api key for using the ESRI tile service. It has not been used now. VITE_JASMIN_OBJECT_STORE_URL: It is necessary to show the bathymetry data VITE_LAYERS_JSON_URL: a json file with the information about the layers. Please set to ./layers.json VITE_LAYERS3D_JSON_URL: a json file with the information about the layuers ./layers.json VITE_MBTILES_URL: [OPTIONAL] the url for the mbtiles tile server. It has not been used now. VITE_TILE_SERVER_URL: the url of the tile server. Please set to https://ceeds-tileserver.resow.uk/ GEOSERVER_ADMIN_USER: the admin username for your geoserver GEOSERVER_ADMIN_PASSWORD: the admin password for your geoserver Setting up the Virtual Machines Create your virtual machines. On JASMIN, this can be done via the Cloud dashboard at JASMIN Cloud Dashboard . Assign an internet IP to the gateway VM. Ensure you can SSH into each VM via the gateway . On the build , tiling , and web VMs, the Docker directory (/var/lib/docker) needs to have plenty of disk space, approximately 50GB, as Docker doesn't always clean up after itself. You can achieve this by either creating a large main disk or creating a second disk and mounting it in /var/lib/docker. If you choose the latter, ensure it gets mounted from the fstab when the VM reboots. Setting up Hostnames and SSL Certificates The following hostnames are used: - ceeds.resow.uk - ceeds-tileserver.resow.uk - ceeds-geooserver.resow.uk Salt is configured to set up Let's Encrypt for these hostnames but might need additional steps to request the initial certificate. Setting up Salt Salt is the configuration management system used to set up the operating system on the VMs. Follow the instructions provided in the Salt Configuration Repository . Setting up GitLab Runners You'll need to configure a GitLab runner on the build . Give this runner the tag \"shell\". The shell runner is used to build Docker containers. Ensure that all three GitLab projects (frontend, geoserver and tileserver) are configured to use these runners.","title":"How to Deploy the Digital Twin to a New Server"},{"location":"deploy/#how-to-deploy-the-digital-twin-to-a-new-server","text":"","title":"How to Deploy the Digital Twin to a New Server"},{"location":"deploy/#prerequisites","text":"You will need four virtual machines running Ubuntu 22.04, each with 4-8GB of RAM and 10GB of disk space for the OS. Additionally, two of these machines should have an extra 50GB of disk space (can be on an additional disk/volume). The four virtual machines are as follows: - gateway : Runs an Apache transparent proxy server for all services, sets up Let's Encrypt certificates, and provides SSL connections to web apps. - web : Runs the web apps as Docker containers. - tiling : Runs the tile servers as Docker containers. - build : Functions as a GitLab runner for building and deploying. Only the gateway VM needs an internet-routable IP address. Ensure that you have set the IP address of each system in the Salt pillar hosts file (pillar/hosts.sls) or made sure that the names gateway , web , and build are resolvable via DNS. These virtual machines can be created using the Salt configuration for this project: Salt Configuration Repository .","title":"Prerequisites"},{"location":"deploy/#environment-configuration","text":"You need to set a list of secrets on the CI/CD configuration on GitLab, as described below: VITE_CESIUM_TOKEN: the token for the Cesium ION Api. It is necessary in order to access the 3d visualisation VITE_MAPBOX_API_KEY: the api key for the mapbox satellite layers VITE_ESRI: [OPTIONAL] the api key for using the ESRI tile service. It has not been used now. VITE_JASMIN_OBJECT_STORE_URL: It is necessary to show the bathymetry data VITE_LAYERS_JSON_URL: a json file with the information about the layers. Please set to ./layers.json VITE_LAYERS3D_JSON_URL: a json file with the information about the layuers ./layers.json VITE_MBTILES_URL: [OPTIONAL] the url for the mbtiles tile server. It has not been used now. VITE_TILE_SERVER_URL: the url of the tile server. Please set to https://ceeds-tileserver.resow.uk/ GEOSERVER_ADMIN_USER: the admin username for your geoserver GEOSERVER_ADMIN_PASSWORD: the admin password for your geoserver","title":"Environment Configuration"},{"location":"deploy/#setting-up-the-virtual-machines","text":"Create your virtual machines. On JASMIN, this can be done via the Cloud dashboard at JASMIN Cloud Dashboard . Assign an internet IP to the gateway VM. Ensure you can SSH into each VM via the gateway . On the build , tiling , and web VMs, the Docker directory (/var/lib/docker) needs to have plenty of disk space, approximately 50GB, as Docker doesn't always clean up after itself. You can achieve this by either creating a large main disk or creating a second disk and mounting it in /var/lib/docker. If you choose the latter, ensure it gets mounted from the fstab when the VM reboots.","title":"Setting up the Virtual Machines"},{"location":"deploy/#setting-up-hostnames-and-ssl-certificates","text":"The following hostnames are used: - ceeds.resow.uk - ceeds-tileserver.resow.uk - ceeds-geooserver.resow.uk Salt is configured to set up Let's Encrypt for these hostnames but might need additional steps to request the initial certificate.","title":"Setting up Hostnames and SSL Certificates"},{"location":"deploy/#setting-up-salt","text":"Salt is the configuration management system used to set up the operating system on the VMs. Follow the instructions provided in the Salt Configuration Repository .","title":"Setting up Salt"},{"location":"deploy/#setting-up-gitlab-runners","text":"You'll need to configure a GitLab runner on the build . Give this runner the tag \"shell\". The shell runner is used to build Docker containers. Ensure that all three GitLab projects (frontend, geoserver and tileserver) are configured to use these runners.","title":"Setting up GitLab Runners"},{"location":"fgb/","text":"FlatGeoBuf Work in progress","title":"FlatGeoBuf"},{"location":"fgb/#flatgeobuf","text":"Work in progress","title":"FlatGeoBuf"},{"location":"frontend/","text":"Frontend Documentation It was created a frontend application developed in React, with the ability to interact with different data formats on both the backend and frontend. The project relies on specific backend services for tile server operations for cloud optimised geotiff files and geoserver. For more information, please refer to the project repository . Access The frontend application is currently hosted on Jasmin and Oracle Cloud, and you can access it through the following link: https://ceeds.resow.uk// General Project Infrastructure The frontend accesses data from various sources and utilizes different microservices. All these services are containerized using Docker for easy deployment and management. Layers Organization The organization of the layers rendered in the application is managed through the STAC Catalog of the project. Using the Data Pipelines package, the STAC is converted into a JSON file that the frontend can interpret and encode. Currently, in the project, these JSON files are stored in the public folder. You should set the correct path for these files in the following environment variables: VITE_LAYERS_JSON_URL and VITE_LAYERS3D_JSON_URL. Features 2D Map The 2D version is based on the React Leaflet library. For comprehensive information on the 2D map, please refer to the 2D Map documentation . 3D Map The 3D version is built using the Resium library, which is Cesium for React. Find more details about the 3D map in the 3D Map documentation . Map Layers The layers used in the maps are generated from the STAC Catalog of the project. To do this, you need to convert the STAC Catalog into a JSON file and save it in the appropriate location. More information about this conversion is available at the repository data-pipelines . It's essential to set this location as environment variables, VITE_LAYERS_JSON_URL and VITE_LAYERS3D_JSON_URL . Interaction with Different Data Types Various techniques are applied to process and render maps for various data formats, including: GeoTIFF and Cloud Optimized GeoTIFF (COG) FlatGeoBuf Geoserver WMS Layers Cesium Ion Frontend Calculations The frontend utilizes the GeoBlaze and georaster libraries for performing specific operations. These libraries is particularly useful for conducting simple statistical operations on GeoTIFF files. When working with COG format images, it's important to download only the necessary tiles and then perform mathematical operations. Layer Upload Work in progress Layer Download Work in progress Image Export Work in progress","title":"Frontend Documentation"},{"location":"frontend/#frontend-documentation","text":"It was created a frontend application developed in React, with the ability to interact with different data formats on both the backend and frontend. The project relies on specific backend services for tile server operations for cloud optimised geotiff files and geoserver. For more information, please refer to the project repository .","title":"Frontend Documentation"},{"location":"frontend/#access","text":"The frontend application is currently hosted on Jasmin and Oracle Cloud, and you can access it through the following link: https://ceeds.resow.uk//","title":"Access"},{"location":"frontend/#general-project-infrastructure","text":"The frontend accesses data from various sources and utilizes different microservices. All these services are containerized using Docker for easy deployment and management.","title":"General Project Infrastructure"},{"location":"frontend/#layers-organization","text":"The organization of the layers rendered in the application is managed through the STAC Catalog of the project. Using the Data Pipelines package, the STAC is converted into a JSON file that the frontend can interpret and encode. Currently, in the project, these JSON files are stored in the public folder. You should set the correct path for these files in the following environment variables: VITE_LAYERS_JSON_URL and VITE_LAYERS3D_JSON_URL.","title":"Layers Organization"},{"location":"frontend/#features","text":"","title":"Features"},{"location":"frontend/#2d-map","text":"The 2D version is based on the React Leaflet library. For comprehensive information on the 2D map, please refer to the 2D Map documentation .","title":"2D Map"},{"location":"frontend/#3d-map","text":"The 3D version is built using the Resium library, which is Cesium for React. Find more details about the 3D map in the 3D Map documentation .","title":"3D Map"},{"location":"frontend/#map-layers","text":"The layers used in the maps are generated from the STAC Catalog of the project. To do this, you need to convert the STAC Catalog into a JSON file and save it in the appropriate location. More information about this conversion is available at the repository data-pipelines . It's essential to set this location as environment variables, VITE_LAYERS_JSON_URL and VITE_LAYERS3D_JSON_URL .","title":"Map Layers"},{"location":"frontend/#interaction-with-different-data-types","text":"Various techniques are applied to process and render maps for various data formats, including: GeoTIFF and Cloud Optimized GeoTIFF (COG) FlatGeoBuf Geoserver WMS Layers Cesium Ion","title":"Interaction with Different Data Types"},{"location":"frontend/#frontend-calculations","text":"The frontend utilizes the GeoBlaze and georaster libraries for performing specific operations. These libraries is particularly useful for conducting simple statistical operations on GeoTIFF files. When working with COG format images, it's important to download only the necessary tiles and then perform mathematical operations.","title":"Frontend Calculations"},{"location":"frontend/#layer-upload","text":"Work in progress","title":"Layer Upload"},{"location":"frontend/#layer-download","text":"Work in progress","title":"Layer Download"},{"location":"frontend/#image-export","text":"Work in progress","title":"Image Export"},{"location":"geoserver/","text":"Geoserver Work in progress","title":"Geoserver"},{"location":"geoserver/#geoserver","text":"Work in progress","title":"Geoserver"},{"location":"geotiff_cog/","text":"GeoTIFF and Cloud Optimized GeoTIFF (COG) Overview This repository documents our approach to using GeoTIFF files for raster data and converting them to Cloud Optimized GeoTIFF (COG) format when handling large files (over 10 MB). Working directly with large GeoTIFF files can be inefficient, as they require full dataset downloads to render in web GIS applications. By converting to COG format, we enable more efficient storage and display of geospatial data, specifically for web applications. This documentation outlines our COG processing approach and highlights the use of a tile server to accelerate frontend map rendering. Benefits of COG Format Cloud Optimized GeoTIFF (COG) files are specially designed for efficient geospatial data storage. They allow quick access and rendering of large datasets without needing to load the entire file, making them ideal for web-based GIS applications. Tile Server Setup Tile Server: Powered by titiler.xyz To access COG images, we use a tile server based on titiler.xyz . Our production tile server is live at the following link: CEEDS Tile Server The source code and configuration for this tile server are available in our GitLab repository: Tile Server Repository . This repository contains all source files, setup information, and documentation needed to understand the implementation. Our project\u2019s 2D and 3D maps leverage this tile server for efficient COG data rendering, resulting in a smooth and optimized user experience. Frontend COG Data Processing In addition to the tile server, we use frontend processing to work with GeoTIFF and COG data via Geoblaze and georaster . These libraries enable direct interaction with COG data in the frontend, allowing various data operations directly within the web application. Example of a 2D map with COG rendering. The chart was created with the Geoblaze library for data extraction and Plotly for visualization.","title":"GeoTIFF and Cloud Optimized GeoTIFF (COG)"},{"location":"geotiff_cog/#geotiff-and-cloud-optimized-geotiff-cog","text":"","title":"GeoTIFF and Cloud Optimized GeoTIFF (COG)"},{"location":"geotiff_cog/#overview","text":"This repository documents our approach to using GeoTIFF files for raster data and converting them to Cloud Optimized GeoTIFF (COG) format when handling large files (over 10 MB). Working directly with large GeoTIFF files can be inefficient, as they require full dataset downloads to render in web GIS applications. By converting to COG format, we enable more efficient storage and display of geospatial data, specifically for web applications. This documentation outlines our COG processing approach and highlights the use of a tile server to accelerate frontend map rendering.","title":"Overview"},{"location":"geotiff_cog/#benefits-of-cog-format","text":"Cloud Optimized GeoTIFF (COG) files are specially designed for efficient geospatial data storage. They allow quick access and rendering of large datasets without needing to load the entire file, making them ideal for web-based GIS applications.","title":"Benefits of COG Format"},{"location":"geotiff_cog/#tile-server-setup","text":"","title":"Tile Server Setup"},{"location":"geotiff_cog/#tile-server-powered-by-titilerxyz","text":"To access COG images, we use a tile server based on titiler.xyz . Our production tile server is live at the following link: CEEDS Tile Server The source code and configuration for this tile server are available in our GitLab repository: Tile Server Repository . This repository contains all source files, setup information, and documentation needed to understand the implementation. Our project\u2019s 2D and 3D maps leverage this tile server for efficient COG data rendering, resulting in a smooth and optimized user experience.","title":"Tile Server: Powered by titiler.xyz"},{"location":"geotiff_cog/#frontend-cog-data-processing","text":"In addition to the tile server, we use frontend processing to work with GeoTIFF and COG data via Geoblaze and georaster . These libraries enable direct interaction with COG data in the frontend, allowing various data operations directly within the web application. Example of a 2D map with COG rendering. The chart was created with the Geoblaze library for data extraction and Plotly for visualization.","title":"Frontend COG Data Processing"},{"location":"object_store/","text":"OBJECT STORE ORGANIZATION This document provides a description of the organization of the Pilot-imfe Tenancy on the Jasmin Object Store. The goal is to facilitate future applications of the same infrastructure in new digital twin or GIS systems projects. REQUIREMENTS For the assembly of an infrastructure for digital twin projects, some system requirements are necessary: - The bucket must have open access. A significant portion of the data will be made available to the public through the publication of the data's DOI. Therefore, it is important that the public can download most of the data without login issues or the need for registration. The bucket must have access control for some types of files. Depending on the data, the client may request that it has restricted access. The bucket must support versioning. Depending on the data format on the frontend, some libraries require that the bucket has version control. File Types The bucket must contain all CSV files, COG images, GeoTIFFs, PNGs, JPGs, as well as MBTILES, GEOJSON, SHP, and GEOPARQUET files. The bucket must include the structure and JSON of the STAC catalog. The bucket should contain all JSON files related to the catalogs and data of the STAC catalog. The bucket must contain the files used to populate the frontend. If the frontend requires images or JSON files to populate the site, they should be stored in the bucket. BUCKETS In order to meet all the requirements described above and at the same time align with the space and scalability needs of the project, the following bucket configuration was chosen: 1 bucket to store open access data without versioning control. 1 bucket to store data with access control. 1 bucket with versioning control. The three buckets will have the same data organization, which will facilitate interoperability between them. In other words, if a file needs to be accessed in the access-controlled bucket, the data path will be the same as if the file were in the open bucket. FILE SYSTEM The buckets have the following folder organization: \u251c\u2500\u2500 frontend \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u251c\u2500\u2500 image1.png \u2502 \u251c\u2500\u2500 layers.json \u2502 \u251c\u2500\u2500 layers3d.json \u2502 \u251c\u2500\u2500 website.json \u251c\u2500\u2500 STAC_Catalogue \u2502 \u251c\u2500\u2500 layer_type1 \u2502 \u2502 \u251c\u2500\u2500 layer1 \u2502 \u2502 \u2502 \u251c\u2500\u2500 layer1.json \u2502 \u2502 \u251c\u2500\u2500 colection.json \u2502 \u251c\u2500\u2500 layer_type2 \u2502 \u251c\u2500\u2500 catalog.json \u251c\u2500\u2500 layers \u2502 \u251c\u2500\u2500 layer_type1 \u2502 \u2502 \u251c\u2500\u2500 layer1 \u2502 \u2502 \u2502 \u251c\u2500\u2500 aditional directiories \u2502 \u2502 \u2502 \u251c\u2500\u2500 layer1.csv or .tif or .mbtiles or ... \u2502 \u2502 \u251c\u2500\u2500 layer2 \u2502 \u251c\u2500\u2500 layer_type2 \u2502 \u2502 \u251c\u2500\u2500 layer1 \u2502 \u2502 \u251c\u2500\u2500 layer2 \u2514\u2500\u2500","title":"OBJECT STORE ORGANIZATION"},{"location":"object_store/#object-store-organization","text":"This document provides a description of the organization of the Pilot-imfe Tenancy on the Jasmin Object Store. The goal is to facilitate future applications of the same infrastructure in new digital twin or GIS systems projects.","title":"OBJECT STORE ORGANIZATION"},{"location":"object_store/#requirements","text":"For the assembly of an infrastructure for digital twin projects, some system requirements are necessary: - The bucket must have open access. A significant portion of the data will be made available to the public through the publication of the data's DOI. Therefore, it is important that the public can download most of the data without login issues or the need for registration. The bucket must have access control for some types of files. Depending on the data, the client may request that it has restricted access. The bucket must support versioning. Depending on the data format on the frontend, some libraries require that the bucket has version control. File Types The bucket must contain all CSV files, COG images, GeoTIFFs, PNGs, JPGs, as well as MBTILES, GEOJSON, SHP, and GEOPARQUET files. The bucket must include the structure and JSON of the STAC catalog. The bucket should contain all JSON files related to the catalogs and data of the STAC catalog. The bucket must contain the files used to populate the frontend. If the frontend requires images or JSON files to populate the site, they should be stored in the bucket.","title":"REQUIREMENTS"},{"location":"object_store/#buckets","text":"In order to meet all the requirements described above and at the same time align with the space and scalability needs of the project, the following bucket configuration was chosen: 1 bucket to store open access data without versioning control. 1 bucket to store data with access control. 1 bucket with versioning control. The three buckets will have the same data organization, which will facilitate interoperability between them. In other words, if a file needs to be accessed in the access-controlled bucket, the data path will be the same as if the file were in the open bucket.","title":"BUCKETS"},{"location":"object_store/#file-system","text":"The buckets have the following folder organization: \u251c\u2500\u2500 frontend \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u251c\u2500\u2500 image1.png \u2502 \u251c\u2500\u2500 layers.json \u2502 \u251c\u2500\u2500 layers3d.json \u2502 \u251c\u2500\u2500 website.json \u251c\u2500\u2500 STAC_Catalogue \u2502 \u251c\u2500\u2500 layer_type1 \u2502 \u2502 \u251c\u2500\u2500 layer1 \u2502 \u2502 \u2502 \u251c\u2500\u2500 layer1.json \u2502 \u2502 \u251c\u2500\u2500 colection.json \u2502 \u251c\u2500\u2500 layer_type2 \u2502 \u251c\u2500\u2500 catalog.json \u251c\u2500\u2500 layers \u2502 \u251c\u2500\u2500 layer_type1 \u2502 \u2502 \u251c\u2500\u2500 layer1 \u2502 \u2502 \u2502 \u251c\u2500\u2500 aditional directiories \u2502 \u2502 \u2502 \u251c\u2500\u2500 layer1.csv or .tif or .mbtiles or ... \u2502 \u2502 \u251c\u2500\u2500 layer2 \u2502 \u251c\u2500\u2500 layer_type2 \u2502 \u2502 \u251c\u2500\u2500 layer1 \u2502 \u2502 \u251c\u2500\u2500 layer2 \u2514\u2500\u2500","title":"FILE SYSTEM"},{"location":"stac/","text":"STAC Catalog In order to manage a group of files within the object store, it is essential to create a catalog known as a STAC Catalog . The STAC specification provides a common language for describing geospatial information, making it easier to work with, index, and discover such data. You can access the STAC catalog for this project at this link . For detailed information on generating a STAC Catalog, please refer to the Data Pipelines repository . Creating STAC Catalogs To create STAC Catalogs for this project, you'll need to utilize the Data Pipelines Package . Follow these steps: Create a set of configuration files referred to as \"metadata.\" Metadata files include a primary JSON file representing the main catalog. Depending on the data group, if you wish to add sub-catalogs to your catalog, you can create auxiliary JSON files. The repository provides a list of example files. Import the function and create an instance of the class in Python: from create_stac.stac_gen import STACGen # Create an instance of the class and provide the path to your metadata files (JSON files) s = STACGen(metadata_path='../metadatas/') Generate the STAC Catalog: s.stac_gen(upload_bucket=True, stac_path='stac' ) Upon completion, a folder named \"stac\" will be created containing your STAC Catalog. Generating JSON for Web Applications When using STAC Catalogs in a frontend, importing all the individual files can be time-consuming. To expedite this process, a set of scripts has been created to convert the STAC into a single user-friendly JSON format that can be accepted by web applications. Currently, we are converting the STAC into a JSON format suitable for the \"Haig Fras Digital Twin\" project. To generate the JSON file, follow these steps: Import the function and create an instance of the class in Python: from create_stac.stac_convert import STACConvert c = STACConvert(bucket_path='', stac_path='stac') Generate the JSON file from the STAC Catalog: c.convert() Save the final JSON file and upload it to the object store: c.save_and upload(filename='layers.json') At this point, a file named \"layers.json\" will be created and ready for use by the web application. Set the following environment variables in your frontend project with information related to the path of your JSON file: \"VITE_LAYERS_JSON_URL\" and \"VITE_LAYERS3D_JSON_URL\".","title":"STAC Catalog"},{"location":"stac/#stac-catalog","text":"In order to manage a group of files within the object store, it is essential to create a catalog known as a STAC Catalog . The STAC specification provides a common language for describing geospatial information, making it easier to work with, index, and discover such data. You can access the STAC catalog for this project at this link . For detailed information on generating a STAC Catalog, please refer to the Data Pipelines repository .","title":"STAC Catalog"},{"location":"stac/#creating-stac-catalogs","text":"To create STAC Catalogs for this project, you'll need to utilize the Data Pipelines Package . Follow these steps: Create a set of configuration files referred to as \"metadata.\" Metadata files include a primary JSON file representing the main catalog. Depending on the data group, if you wish to add sub-catalogs to your catalog, you can create auxiliary JSON files. The repository provides a list of example files. Import the function and create an instance of the class in Python: from create_stac.stac_gen import STACGen # Create an instance of the class and provide the path to your metadata files (JSON files) s = STACGen(metadata_path='../metadatas/') Generate the STAC Catalog: s.stac_gen(upload_bucket=True, stac_path='stac' ) Upon completion, a folder named \"stac\" will be created containing your STAC Catalog.","title":"Creating STAC Catalogs"},{"location":"stac/#generating-json-for-web-applications","text":"When using STAC Catalogs in a frontend, importing all the individual files can be time-consuming. To expedite this process, a set of scripts has been created to convert the STAC into a single user-friendly JSON format that can be accepted by web applications. Currently, we are converting the STAC into a JSON format suitable for the \"Haig Fras Digital Twin\" project. To generate the JSON file, follow these steps: Import the function and create an instance of the class in Python: from create_stac.stac_convert import STACConvert c = STACConvert(bucket_path='', stac_path='stac') Generate the JSON file from the STAC Catalog: c.convert() Save the final JSON file and upload it to the object store: c.save_and upload(filename='layers.json') At this point, a file named \"layers.json\" will be created and ready for use by the web application. Set the following environment variables in your frontend project with information related to the path of your JSON file: \"VITE_LAYERS_JSON_URL\" and \"VITE_LAYERS3D_JSON_URL\".","title":"Generating JSON for Web Applications"},{"location":"wms/","text":"WMS Layers This guide will walk you through the process of loading Web Map Service (WMS) layers in a React application using React-Leaflet for 2D maps and Resium for 3D maps. WMS is a standard protocol for serving georeferenced map images over the internet. Web Mapping Services from the following institutions are being accessed to add layers to the map: - JNCC: https://jncc.gov.uk/our-work/marine-protected-area-mapper/ - EMODNET: https://emodnet.ec.europa.eu/en/emodnet-web-service-documentation Loading WMS Layers with React-Leaflet Import Required Modules Import the necessary modules in your WMSLayer.js file: tsx import React from 'react'; import { MapContainer, TileLayer, WMSTileLayer } from 'react-leaflet'; Define the WMS Layer Define the WMS layer within your component, specifying the URL, layers, and other options: ```tsx export function WMSLayer(){ return ( ); }; Use the Component Import and use your WMSLayer component in your main application file: ```tsx import React from 'react'; import { WMSLayer } from './WMSLayer'; export function App() { return ( ); } export default App; ``` Loading WMS Layers with Resium (3D Maps) Import Required Modules tsx import React from 'react'; import { Viewer, ImageryLayer } from 'resium'; import Cesium from 'cesium'; Define the WMS Layer Define the WMS layer within your component: tsx export function WMSLayer(){ return ( <Viewer full> <ImageryLayer imageryProvider={new Cesium.WebMapServiceImageryProvider({ url: 'URL_TO_YOUR_WMS_SERVICE', layers: 'LAYER_NAME', })} /> </Viewer> ); };","title":"WMS Layers"},{"location":"wms/#wms-layers","text":"This guide will walk you through the process of loading Web Map Service (WMS) layers in a React application using React-Leaflet for 2D maps and Resium for 3D maps. WMS is a standard protocol for serving georeferenced map images over the internet. Web Mapping Services from the following institutions are being accessed to add layers to the map: - JNCC: https://jncc.gov.uk/our-work/marine-protected-area-mapper/ - EMODNET: https://emodnet.ec.europa.eu/en/emodnet-web-service-documentation","title":"WMS Layers"},{"location":"wms/#loading-wms-layers-with-react-leaflet","text":"Import Required Modules Import the necessary modules in your WMSLayer.js file: tsx import React from 'react'; import { MapContainer, TileLayer, WMSTileLayer } from 'react-leaflet'; Define the WMS Layer Define the WMS layer within your component, specifying the URL, layers, and other options: ```tsx export function WMSLayer(){ return ( ); }; Use the Component Import and use your WMSLayer component in your main application file: ```tsx import React from 'react'; import { WMSLayer } from './WMSLayer'; export function App() { return ( ); } export default App; ```","title":"Loading WMS Layers with React-Leaflet"},{"location":"wms/#loading-wms-layers-with-resium-3d-maps","text":"Import Required Modules tsx import React from 'react'; import { Viewer, ImageryLayer } from 'resium'; import Cesium from 'cesium'; Define the WMS Layer Define the WMS layer within your component: tsx export function WMSLayer(){ return ( <Viewer full> <ImageryLayer imageryProvider={new Cesium.WebMapServiceImageryProvider({ url: 'URL_TO_YOUR_WMS_SERVICE', layers: 'LAYER_NAME', })} /> </Viewer> ); };","title":"Loading WMS Layers with Resium (3D Maps)"}]}